package vm

import (
	"fmt"
	"path/filepath"
	"sort"
	"strings"
)

// MountHelper generates shell commands for mounting virtio-fs shares inside the guest.
type MountHelper struct {
	shares map[string]string // tag â†’ host path
}

// NewMountHelper creates a MountHelper with the given shares.
func NewMountHelper(shares map[string]string) *MountHelper {
	return &MountHelper{shares: shares}
}

// GenerateMountScript returns shell commands to mount all shares.
// mountBase is the base directory in the guest (e.g., "/mnt/host").
// Each share is mounted at {mountBase}/{tag}.
func (h *MountHelper) GenerateMountScript(mountBase string) string {
	if len(h.shares) == 0 {
		return ""
	}

	var lines []string

	// Header with virtiofs availability check
	lines = append(lines,
		"#!/bin/sh",
		"# Mount virtio-fs shared directories",
		"# Generated by vmterminal",
		"",
		"# Check if virtiofs is available",
		"if ! grep -q virtiofs /proc/filesystems 2>/dev/null; then",
		"    echo \"Error: virtiofs not available in this kernel\" >&2",
		"    exit 1",
		"fi",
		"",
	)

	// Sort tags for deterministic output
	tags := make([]string, 0, len(h.shares))
	for tag := range h.shares {
		tags = append(tags, tag)
	}
	sort.Strings(tags)

	// Generate mount commands for each share
	for _, tag := range tags {
		mountpoint := filepath.Join(mountBase, tag)
		lines = append(lines, h.generateMountLines(tag, mountpoint)...)
		lines = append(lines, "")
	}

	return strings.Join(lines, "\n")
}

// GenerateMountCommand returns the command for mounting a single share.
// tag is the virtio-fs mount tag, mountpoint is where to mount in the guest.
func (h *MountHelper) GenerateMountCommand(tag, mountpoint string) string {
	// Quote paths that contain spaces or special characters
	quotedMountpoint := quotePath(mountpoint)
	return fmt.Sprintf("mkdir -p %s && mount -t virtiofs %s %s", quotedMountpoint, tag, quotedMountpoint)
}

// generateMountLines returns the shell lines for mounting a single share.
func (h *MountHelper) generateMountLines(tag, mountpoint string) []string {
	quotedMountpoint := quotePath(mountpoint)
	return []string{
		fmt.Sprintf("# Mount %s", tag),
		fmt.Sprintf("if mountpoint -q %s 2>/dev/null; then", quotedMountpoint),
		fmt.Sprintf("    echo \"%s already mounted\"", tag),
		"else",
		fmt.Sprintf("    mkdir -p %s", quotedMountpoint),
		fmt.Sprintf("    if mount -t virtiofs %s %s; then", tag, quotedMountpoint),
		fmt.Sprintf("        echo \"Mounted %s at %s\"", tag, mountpoint),
		"    else",
		fmt.Sprintf("        echo \"Failed to mount %s\" >&2", tag),
		"    fi",
		"fi",
	}
}

// Tags returns the sorted list of mount tags.
func (h *MountHelper) Tags() []string {
	tags := make([]string, 0, len(h.shares))
	for tag := range h.shares {
		tags = append(tags, tag)
	}
	sort.Strings(tags)
	return tags
}

// HasShares returns true if there are any shares configured.
func (h *MountHelper) HasShares() bool {
	return len(h.shares) > 0
}

// quotePath returns a quoted version of the path if it contains special characters.
func quotePath(path string) string {
	// If path contains spaces or shell metacharacters, quote it
	if strings.ContainsAny(path, " \t'\"$`\\!") {
		// Use single quotes and escape any single quotes within
		escaped := strings.ReplaceAll(path, "'", "'\"'\"'")
		return "'" + escaped + "'"
	}
	return path
}
